{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the wai-annotations manual! Installation - how to install the library Usage - running the library from the command-line Examples - common use-cases Plugin Guide - adding new domains/formats/conversions Domains - supported domains Plugins - available plugins Glossary - explanations of terms","title":"Home"},{"location":"conversion_options/","text":"Conversion options for wai-annotations The following options can be specified before any stages in the conversion chain, and globally affect the process of converting datasets: -h , --help : Lists this set of conversion options and then exits. -v : Optional argument to set the logging verbosity of the conversion. Can be specified multiple times to further increase verbosity. --macro-file : The macros to use during the conversion.","title":"Conversion options for wai-annotations"},{"location":"conversion_options/#conversion-options-for-wai-annotations","text":"The following options can be specified before any stages in the conversion chain, and globally affect the process of converting datasets: -h , --help : Lists this set of conversion options and then exits. -v : Optional argument to set the logging verbosity of the conversion. Can be specified multiple times to further increase verbosity. --macro-file : The macros to use during the conversion.","title":"Conversion options for wai-annotations"},{"location":"domains/","text":"Domains Image Classification Domain Images categorised by content. The image classification domain deals with labelling entire images as containing a certain subject. Instances in this domain contain an image and a string label classifying the image. Image Object-Detection Domain Images containing multiple identified objects. The image object-detection domain pertains to finding regions of still images which contain identifiable objects. Instances in this domain consist of an image and a set of regions (either axis-aligned boxes or polygons), each with an accompanying label, identifying the detected objects within the image. Image Segmentation Domain Images segmented by category. The image segmentation domain 'colourises' an image by assigning a category to each pixel (where no category corresponds to 'the background'). Instances in this domain are a still image and a corresponding table of the same size, where each element is a label. Speech Domain Transcriptions of recorded speech. The speech domain covers audio data of people speaking natural languages, annotated with text transcribing the verbal contents of the audio. Instances in this domain are an audio file and a string containing the transcription.","title":"Domains"},{"location":"domains/#domains","text":"","title":"Domains"},{"location":"domains/#image-classification-domain","text":"Images categorised by content. The image classification domain deals with labelling entire images as containing a certain subject. Instances in this domain contain an image and a string label classifying the image.","title":"Image Classification Domain"},{"location":"domains/#image-object-detection-domain","text":"Images containing multiple identified objects. The image object-detection domain pertains to finding regions of still images which contain identifiable objects. Instances in this domain consist of an image and a set of regions (either axis-aligned boxes or polygons), each with an accompanying label, identifying the detected objects within the image.","title":"Image Object-Detection Domain"},{"location":"domains/#image-segmentation-domain","text":"Images segmented by category. The image segmentation domain 'colourises' an image by assigning a category to each pixel (where no category corresponds to 'the background'). Instances in this domain are a still image and a corresponding table of the same size, where each element is a label.","title":"Image Segmentation Domain"},{"location":"domains/#speech-domain","text":"Transcriptions of recorded speech. The speech domain covers audio data of people speaking natural languages, annotated with text transcribing the verbal contents of the audio. Instances in this domain are an audio file and a string containing the transcription.","title":"Speech Domain"},{"location":"examples/","text":"Examples Tip: While building a conversion pipeline command, open a separate terminal to quickly output the available plugins ( wai-annotations plugins ) and the help for a specific plugin ( wai-annotations plugins -o PLUGINNAME ). NB: In the examples below, input and output represent directories, which you will have to adapt. Format conversions ADAMS to MS-COCO Also adds additional logging information and removes annotations smaller than 5 pixels in either dimension. wai-annotations convert -v \\ from-adams-od -i input \\ dimension-discarder --min-width 5 --min-height 5 \\ to-coco-od -o output/annotations.json --license-name \"my license\" --no-images Monolithic Tensorflow records to sharded ones Here we are converting a monolithic TFRecords file into a sharded one ( -s 5 - five shards) and only using a subset of labels ( -l label2,label4,label6 ): wai-annotations convert \\ from-tfrecords-od -i input/objects.records \\ filter-labels -l label2,label4,label6 \\ to-tfrecords-od -o output/subset.records -s 5 -p labels.pbtxt ADAMS to Tensorflow records (masks) The ADAMS input directory contains sub-directories, so we use the \"input/**/*.report\" glob syntax to find all .report files recursively. The data gets split into train/test with a 80/20 ratio. Supplying split names will automatically insert these names into the output file, i.e., output/data.tfrecords will get turned into output/train/data.tfrecords and output/test/data.tfrecords . No path gets supplied to the file containing the labels ( labels.txt ), it will get placed into the correct output directory automatically: wai-annotations convert \\ from-adams-od -i \"input/**/*.report\" \\ coerce-mask \\ to-tf-od -o output/data.tfrecords -p labels.txt --split-names train test --split-ratios 80 20 ADAMS individual layer image segmentation to blue channel JPGs ADAMS supports the individual layers format for image segmentation format, where for each JPG image a PNG with the same file name plus the label suffix is present (e.g.g: 1.jpg -> 1-car.png and 1-person.png). In this case, we only want to include the car annotations in the output. The output gets split into train/val with a ratio of 80/20: wai-annotations convert \\ from-layer-segments-is -i \"input/**/*.png\" --labels car \\ to-indexed-png-is -o output --split-names train val --split-ratios 80 20 Image augmentation The following command-line loads ADAMS annotations and saves augmented MSCOCO ones. The pipeline adds augmented images ( -m add ) that are cropped, flipped, blurred, rotated and scaled. Each inline stream processor changes randomly about 10% of the images ( -T 0.9 ). The augmentation is seeded ( -s 1 -a ) to generate reproducible datasets: wai-annotations convert \\ from-adams-od -i \"input/**/*.report\" \\ crop -a -m add -T 0.9 -f 0.0 -t 0.1 \\ # crop 0-10% of the image flip -a -m add -T 0.9 -d lr \\ # flip left-to-right gaussian-blur -a -m add -T 0.9 -f 0.2 -t 0.5 \\ # sigma from 0.2-0.5 rotate -a -m add -T 0.9 -f=-10 -t=10 \\ # rotate from -10 to +10 degrees scale -a -m add -T 0.9 -f 0.8 -t 1.2 -k -u \\ # scale from 80 to 120%, keeping aspect ratio, resizing the image to-coco-od -o output/annotations.json","title":"Examples"},{"location":"examples/#examples","text":"Tip: While building a conversion pipeline command, open a separate terminal to quickly output the available plugins ( wai-annotations plugins ) and the help for a specific plugin ( wai-annotations plugins -o PLUGINNAME ). NB: In the examples below, input and output represent directories, which you will have to adapt.","title":"Examples"},{"location":"examples/#format-conversions","text":"","title":"Format conversions"},{"location":"examples/#adams-to-ms-coco","text":"Also adds additional logging information and removes annotations smaller than 5 pixels in either dimension. wai-annotations convert -v \\ from-adams-od -i input \\ dimension-discarder --min-width 5 --min-height 5 \\ to-coco-od -o output/annotations.json --license-name \"my license\" --no-images","title":"ADAMS to MS-COCO"},{"location":"examples/#monolithic-tensorflow-records-to-sharded-ones","text":"Here we are converting a monolithic TFRecords file into a sharded one ( -s 5 - five shards) and only using a subset of labels ( -l label2,label4,label6 ): wai-annotations convert \\ from-tfrecords-od -i input/objects.records \\ filter-labels -l label2,label4,label6 \\ to-tfrecords-od -o output/subset.records -s 5 -p labels.pbtxt","title":"Monolithic Tensorflow records to sharded ones"},{"location":"examples/#adams-to-tensorflow-records-masks","text":"The ADAMS input directory contains sub-directories, so we use the \"input/**/*.report\" glob syntax to find all .report files recursively. The data gets split into train/test with a 80/20 ratio. Supplying split names will automatically insert these names into the output file, i.e., output/data.tfrecords will get turned into output/train/data.tfrecords and output/test/data.tfrecords . No path gets supplied to the file containing the labels ( labels.txt ), it will get placed into the correct output directory automatically: wai-annotations convert \\ from-adams-od -i \"input/**/*.report\" \\ coerce-mask \\ to-tf-od -o output/data.tfrecords -p labels.txt --split-names train test --split-ratios 80 20","title":"ADAMS to Tensorflow records (masks)"},{"location":"examples/#adams-individual-layer-image-segmentation-to-blue-channel-jpgs","text":"ADAMS supports the individual layers format for image segmentation format, where for each JPG image a PNG with the same file name plus the label suffix is present (e.g.g: 1.jpg -> 1-car.png and 1-person.png). In this case, we only want to include the car annotations in the output. The output gets split into train/val with a ratio of 80/20: wai-annotations convert \\ from-layer-segments-is -i \"input/**/*.png\" --labels car \\ to-indexed-png-is -o output --split-names train val --split-ratios 80 20","title":"ADAMS individual layer image segmentation to blue channel JPGs"},{"location":"examples/#image-augmentation","text":"The following command-line loads ADAMS annotations and saves augmented MSCOCO ones. The pipeline adds augmented images ( -m add ) that are cropped, flipped, blurred, rotated and scaled. Each inline stream processor changes randomly about 10% of the images ( -T 0.9 ). The augmentation is seeded ( -s 1 -a ) to generate reproducible datasets: wai-annotations convert \\ from-adams-od -i \"input/**/*.report\" \\ crop -a -m add -T 0.9 -f 0.0 -t 0.1 \\ # crop 0-10% of the image flip -a -m add -T 0.9 -d lr \\ # flip left-to-right gaussian-blur -a -m add -T 0.9 -f 0.2 -t 0.5 \\ # sigma from 0.2-0.5 rotate -a -m add -T 0.9 -f=-10 -t=10 \\ # rotate from -10 to +10 degrees scale -a -m add -T 0.9 -f 0.8 -t 1.2 -k -u \\ # scale from 80 to 120%, keeping aspect ratio, resizing the image to-coco-od -o output/annotations.json","title":"Image augmentation"},{"location":"glossary/","text":"Glossary Glossary of terminology used in wai-annotations. Component - A single participating element in a pipeline. Can be a source (inserts items into the start of a pipeline), a sink (consumes items from the end of a pipeline), or a processor (an intermediary element which performs some operation on the items in the pipeline). Conversion Pipeline - A series of stages comprising a complete conversion sequence, consisting of an input format, a series of intermediate processing stages, and a final output format. Cross-Domain Converter (XDC) - An intermediate processor which converts a dataset from one domain to another. For example, a video-based domain could be converted to an image-based domain by treating each frame of the video as an individual image. Domain - A specific type of data, being annotated in a specific manner. For example, datasets in the image object-detection domain consist of still images annotated with regions containing identified objects. Format - An external representation of a domain. This is typically a way of storing instances of the domain on disk. Inline Stream Processor (ISP) - An intermediate processor in the conversion chain, which performs some mutation of the items in a dataset. ISPs cannot change the domain of a dataset. For example, an ISP might remove images that are smaller than a certain size from the conversion stream (for image-based domains). Instance - A specific example of data-item and its annotations in a given domain. Macro - A command-line keyword which is used in place of a series of command-line options. Macros are stored in a JSON file, and specified to wai.annotations via the --macro-file command-line option. Negative Example - An item in a dataset which has no annotations. These are typically used when learning to provide examples of what not to look for. Plugin - An implementation of a stage which can be used by wai.annotations to perform some feature. Plugins can be specified by external modules via the wai.annotations.plugins entry-point in their setup.py script. Plugin Specifier - A class which advertises the components that a particular plugin offers for use with wai-annotations. Pipeline - A series of components which process items in their defined order, each passing its output to the next. Specifier - A class used to advertise a stage/domain to wai.annotations from an external module. Splitting - Because wai.annotations only supports linear pipelines, many formats support splitting of their outputs over a number of output directories. Stage - A collection of components which produces, consumes or processes instances.","title":"Glossary"},{"location":"glossary/#glossary","text":"Glossary of terminology used in wai-annotations. Component - A single participating element in a pipeline. Can be a source (inserts items into the start of a pipeline), a sink (consumes items from the end of a pipeline), or a processor (an intermediary element which performs some operation on the items in the pipeline). Conversion Pipeline - A series of stages comprising a complete conversion sequence, consisting of an input format, a series of intermediate processing stages, and a final output format. Cross-Domain Converter (XDC) - An intermediate processor which converts a dataset from one domain to another. For example, a video-based domain could be converted to an image-based domain by treating each frame of the video as an individual image. Domain - A specific type of data, being annotated in a specific manner. For example, datasets in the image object-detection domain consist of still images annotated with regions containing identified objects. Format - An external representation of a domain. This is typically a way of storing instances of the domain on disk. Inline Stream Processor (ISP) - An intermediate processor in the conversion chain, which performs some mutation of the items in a dataset. ISPs cannot change the domain of a dataset. For example, an ISP might remove images that are smaller than a certain size from the conversion stream (for image-based domains). Instance - A specific example of data-item and its annotations in a given domain. Macro - A command-line keyword which is used in place of a series of command-line options. Macros are stored in a JSON file, and specified to wai.annotations via the --macro-file command-line option. Negative Example - An item in a dataset which has no annotations. These are typically used when learning to provide examples of what not to look for. Plugin - An implementation of a stage which can be used by wai.annotations to perform some feature. Plugins can be specified by external modules via the wai.annotations.plugins entry-point in their setup.py script. Plugin Specifier - A class which advertises the components that a particular plugin offers for use with wai-annotations. Pipeline - A series of components which process items in their defined order, each passing its output to the next. Specifier - A class used to advertise a stage/domain to wai.annotations from an external module. Splitting - Because wai.annotations only supports linear pipelines, many formats support splitting of their outputs over a number of output directories. Stage - A collection of components which produces, consumes or processes instances.","title":"Glossary"},{"location":"install/","text":"Installation of wai-annotations To install wai-annotations issue the following commands using pip: pip install wai.annotations.core wai-annotations-core does not come with any input/output formats installed. You will need to install a plugin for each format that you want to convert between. For a description of the plugin system, see the plugin guide . For installing all available plugins, use this command: pip install wai.annotations Available plugins Image classification https://github.com/waikato-ufdl/wai-annotations-adams https://github.com/waikato-ufdl/wai-annotations-subdir Object detection https://github.com/waikato-ufdl/wai-annotations-adams https://github.com/waikato-ufdl/wai-annotations-coco https://github.com/waikato-ufdl/wai-annotations-roi https://github.com/waikato-ufdl/wai-annotations-tf https://github.com/waikato-ufdl/wai-annotations-vgg https://github.com/waikato-ufdl/wai-annotations-voc https://github.com/waikato-ufdl/wai-annotations-yolo Image segmentation https://github.com/waikato-ufdl/wai-annotations-bluechannel https://github.com/waikato-ufdl/wai-annotations-indexedpng https://github.com/waikato-ufdl/wai-annotations-layersegments Audio https://github.com/waikato-ufdl/wai-annotations-commonvoice https://github.com/waikato-ufdl/wai-annotations-festvox Image augmentation https://github.com/waikato-ufdl/wai-annotations-imgaug","title":"Installation"},{"location":"install/#installation-of-wai-annotations","text":"To install wai-annotations issue the following commands using pip: pip install wai.annotations.core wai-annotations-core does not come with any input/output formats installed. You will need to install a plugin for each format that you want to convert between. For a description of the plugin system, see the plugin guide . For installing all available plugins, use this command: pip install wai.annotations","title":"Installation of wai-annotations"},{"location":"install/#available-plugins","text":"Image classification https://github.com/waikato-ufdl/wai-annotations-adams https://github.com/waikato-ufdl/wai-annotations-subdir Object detection https://github.com/waikato-ufdl/wai-annotations-adams https://github.com/waikato-ufdl/wai-annotations-coco https://github.com/waikato-ufdl/wai-annotations-roi https://github.com/waikato-ufdl/wai-annotations-tf https://github.com/waikato-ufdl/wai-annotations-vgg https://github.com/waikato-ufdl/wai-annotations-voc https://github.com/waikato-ufdl/wai-annotations-yolo Image segmentation https://github.com/waikato-ufdl/wai-annotations-bluechannel https://github.com/waikato-ufdl/wai-annotations-indexedpng https://github.com/waikato-ufdl/wai-annotations-layersegments Audio https://github.com/waikato-ufdl/wai-annotations-commonvoice https://github.com/waikato-ufdl/wai-annotations-festvox Image augmentation https://github.com/waikato-ufdl/wai-annotations-imgaug","title":"Available plugins"},{"location":"plugin/","text":"Adding components to wai-annotations through plugins wai-annotations uses a plugin system to allow other libraries to add new processing components without modifying the base library source. This document details how to go about using this system. Plugin Types There are 4 types of components which can be added to wai-annotations via plugin: input formats, ISPs, XDCs and output formats. New domains can also be added, but these are specified indirectly via any of the previous components. Domains New domains are added indirectly to wai-annotations as dependencies of components, as a domain which has no components is essentially unreachable to a conversion chain. However the specification of new domains is treated as a plugin-related issue, so it is detailed here. A domain is essentially the definition of an instance format, which contains both an item in the conversion dataset and the annotations attached to that item. The actual item in the dataset is represented by a FileInfo object, which contains the name of the item, and the binary data blob containing the item's file data. Domains need to specify a sub-class of FileInfo to represent the item and any additional data about it. The annotations for an instance can be any arbitrary type. To specify a new domain, a domain specifier must be created. This is achieved by importing the base classes from the core wai-annotations package and implementing the abstract methods. from typing import Type from wai.annotations.core.instance import FileInfo, Instance from wai.annotations.core.specifier import DomainSpecifier # Define the file-info type which holds dataset item data class MyFileInfo(FileInfo): @classmethod def from_file_data(cls, file_name: str, file_data: bytes) -> 'MyFileInfo': # If we don't need any additional information, or it is calculated in the init method return cls(file_name, file_data) # Define the type of annotations for the domain class MyAnnotations: ... # Define an instance type with additional functionality, if required class MyInstance(Instance[MyFileInfo, MyAnnotations]): def additional_method(self): ... # Define the domain specifier reporting the various classes for domain instances class MyDomainSpecifier(DomainSpecifier): @classmethod def domain_name(cls) -> str: return \"my domain\" @classmethod def file_type(cls) -> Type[MyFileInfo]: return MyFileInfo @classmethod def annotations_type(cls) -> Type[MyAnnotations]: return MyAnnotations # If our instances need additional functionality, we can override this method. The default is # wai.annotations.core.instance.Instance[cls.file_type(), cls.annotations_type()], and if we # do override this method, the type returned must inherit from this default type. @classmethod def instance_class(cls) -> Type[Instance]: return MyInstance Writing New Components The base classes for components can be imported from wai-annotations' core package: from wai.annotations.core.component import Reader, InputConverter # For input formats from wai.annotations.core.component import InlineStreamProcessor # For ISPs from wai.annotations.core.component import CrossDomainConverter # For XDCs from wai.annotations.core.component import Writer, OutputConverter # For output formats Sub-class the base classes for the type of component you are trying to implement, and fill in the generic type-parameters and abstract methods. For generic type-parameters, component base classes vary on instance types, which are defined in the domain specifier for the domains the component operates in. Therefore the best way to specify the instance type-parameter is to import the domain specifiers for the domains of interest and use their instance_class() methods. For the abstract methods, each component has a few methods which require implementation. The purpose of each should be fairly self-explanatory, but the following examples will (hopefully) illustrate how to use each base class. Input Formats Input formats consist of 2 components, a reader and an input-converter. The reader reads files from disk into an arbitrary format, and the input-converter converts that format into the instance format for the domain of the dataset. An example of how to implement a new input-format: from typing import Iterator, IO, Type from wai.annotations.core.component import Reader, InputConverter from wai.annotations.core.specifier import InputFormatSpecifier from wai.annotations.domain.image.object_detection import ImageObjectDetectionDomainSpecifier # Get the instance type from the domain specifier ImageObjectDetectionInstance = ImageObjectDetectionDomainSpecifier.instance_class() # Define the external format in any way you like (if being used with an output format as well, # define separately and import) class MyExternalFormat: @classmethod def from_annotation_file(cls, file: IO[bytes]) -> 'MyExternalFormat': ... @classmethod def from_negative_file(cls, file: IO[bytes]) -> 'MyExternalFormat': ... def to_image_object_detection_instance(self) -> ImageObjectDetectionInstance: ... # Define your reader, which parses files into your external format class MyReader(Reader[MyExternalFormat]): # Returns an iterator of instances in the given file, in case a single file # contains multiple dataset items def read_annotation_file(self, filename: str) -> Iterator[MyExternalFormat]: with open(filename, \"rb\") as file: yield MyExternalFormat.from_annotation_file(file) # Returns an iterator of negative instances in the given file def read_negative_file(self, filename: str) -> Iterator[MyExternalFormat]: with open(filename, \"rb\") as file: yield MyExternalFormat.from_negative_file(file) # Define your input converter, which converts your external format into the domain of interest (image object-detection # in this example) class MyInputConverter(InputConverter[MyExternalFormat, ImageObjectDetectionInstance]): # Converts the instance from its external format to the domain format def convert(self, instance: MyExternalFormat) -> Iterator[ImageObjectDetectionInstance]: yield instance.to_image_object_detection_instance() # Create a specifier to advertise our input format to the plugin system class MyInputFormatSpecifier(InputFormatSpecifier): # The domain of the input format @classmethod def domain(cls) -> Type[ImageObjectDetectionDomainSpecifier]: return ImageObjectDetectionDomainSpecifier # The reader class we defined earlier @classmethod def reader(cls) -> Type[MyReader]: return MyReader # The input converter class we defined earlier @classmethod def input_converter(cls) -> Type[MyInputConverter]: return MyInputConverter Inline Stream Processors from typing import Iterable, Optional, Set, Type from wai.annotations.core.component import InlineStreamProcessor from wai.annotations.core.specifier import ISPSpecifier, DomainSpecifier from wai.annotations.domain.image.object_detection import ImageObjectDetectionDomainSpecifier # Get the instance type from the domain specifier ImageObjectDetectionInstance = ImageObjectDetectionDomainSpecifier.instance_class() # Define the ISP class MyISP(InlineStreamProcessor[ImageObjectDetectionInstance]): # Takes an instance from the conversion stream and processes it. Returns an iterable so that new # instances can be injected into the conversion stream, or removed from it def _process_element(self, element: ImageObjectDetectionInstance) -> Iterable[ImageObjectDetectionInstance]: ... # Advertise the ISP to the plugin system via a specifier class MyISPSpecifier(ISPSpecifier): # Specifies the domains this ISP can operate on. None indicates any domain, and a set indicates # a set of specific domains @classmethod def domains(cls) -> Optional[Set[Type[DomainSpecifier]]]: return {ImageObjectDetectionDomainSpecifier} # The actual ISP type we defined earlier @classmethod def processor_type(cls) -> Type[InlineStreamProcessor]: return MyISP Cross-Domain Converters from typing import Iterable, Type from wai.annotations.core.component import CrossDomainConverter from wai.annotations.core.specifier import XDCSpecifier, DomainSpecifier from wai.annotations.domain.image.classification import ImageClassificationDomainSpecifier from wai.annotations.domain.image.object_detection import ImageObjectDetectionDomainSpecifier # Get the instance types from the domain specifiers ImageClassificationInstance = ImageClassificationDomainSpecifier.instance_class() ImageObjectDetectionInstance = ImageObjectDetectionDomainSpecifier.instance_class() # Define your XDC, in this case converting from the image object-detection domain to # the image classification domain class MyXDC(CrossDomainConverter[ImageObjectDetectionInstance, ImageClassificationInstance]): # Convert the instance, returning an iterable again to allow insertion/deletion of instances def _convert_element(self, element: ImageObjectDetectionInstance) -> Iterable[ImageClassificationInstance]: ... # Define the specifier to advertise our new XDC to the plugin system class MyXDCSpecifier(XDCSpecifier): # Declare the input domain of the converter @classmethod def from_domain(cls) -> Type[DomainSpecifier]: return ImageObjectDetectionDomainSpecifier # Declare the output domain of the converter @classmethod def to_domain(cls) -> Type[DomainSpecifier]: return ImageClassificationDomainSpecifier # Advertise our XDC defined earlier @classmethod def converter(cls) -> Type[CrossDomainConverter]: return MyXDC Output Formats Output formats also consist of 2 components, a writer and an output-converter. The output-converter converts instances from the domain format to an arbitrary external format for the output format, and the writer writes the instances in that format to disk. An example of how to implement a new output-format: from typing import Iterator, IO, Type, Iterable from wai.annotations.core.component import Writer, OutputConverter from wai.annotations.core.instance import FileInfo from wai.annotations.core.specifier import OutputFormatSpecifier, DomainSpecifier from wai.annotations.domain.image.object_detection import ImageObjectDetectionDomainSpecifier # Get the instance type from the domain specifier ImageObjectDetectionInstance = ImageObjectDetectionDomainSpecifier.instance_class() # Define the external format in any way you like (if being used with an input format as well, define # separately and import) class MyExternalFormat: @classmethod def from_image_object_detection_instance(cls, instance: ImageObjectDetectionInstance) -> 'MyExternalFormat': ... # Define your writer, which writes instances of your external format to disk class MyWriter(Writer[MyExternalFormat]): # Depending on the external format, it might write all instances to a single file, # or each instance to its own file in a directory. Provide some helpful information # on which is the case here @classmethod def output_help_text(cls) -> str: ... # How to write the actual instances to disk def write(self, instances: Iterable[MyExternalFormat], path: str): ... # Whether the output option should be a file (if not, then it should be # a directory) def expects_file(self) -> bool: ... # Lets wai-annotations extract the file from your external format def extract_file_info_from_external_format(self, instance: MyExternalFormat) -> FileInfo: ... # Define your output converter, which converts instances from the format's domain (image object-detection # in this example) into your external format class MyOutputConverter(OutputConverter[ImageObjectDetectionInstance, MyExternalFormat]): # Converts the instance from the domain format into your external format def convert(self, instance: ImageObjectDetectionInstance) -> Iterator[MyExternalFormat]: yield MyExternalFormat.from_image_object_detection_instance(instance) # Create a specifier to advertise our output format to the plugin system class MyOutputFormatSpecifier(OutputFormatSpecifier): # Specify the domain the format is in @classmethod def domain(cls) -> Type[DomainSpecifier]: return ImageObjectDetectionDomainSpecifier # Specify the writer we declared earlier @classmethod def writer(cls) -> Type[Writer]: return MyWriter # Specify the output converter we declared earlier @classmethod def output_converter(cls) -> Type[OutputConverter]: return MyOutputConverter Best Practice Although in each of the examples shown here, we have defined our plugin specifiers in the same file as the components they advertise, this is not the recommended approach. The specifier types should instead be defined in their own sub-package, and the methods should locally import the specified types (instead of globally at the beginning of the specifier Python file). This is so the specifier can be imported into the plugin system without importing potentially heavy-weight libraries that the components depend on for their functionality. This way the system can provide reflection of the available plugins, but only load those plugins that are actually selected for use in a conversion. Advertising Plugins In order for wai-annotations to recognise your plugin, the specified needs to be advertised as an entry point in your setup script under the wai.annotations.plugins group: # setup.py from setuptools import setup setup( ..., entry_points={ \"wai.annotations.plugins\": [ # Input Formats \"from-my-input-format=com.example.specifiers:MyInputFormatSpecifier\", # Output Formats \"to-my-output-format=com.example.specifiers:MyOutputFormatSpecifier\", # ISPs \"my-isp=com.example.specifiers:MyISPSpecifier\", # XDCs \"my-xdc=com.example.specifiers:MyXDCSpecifier\" ] } ) Adding Command-Line Options to Plugin Components TODO","title":"Plugin guide"},{"location":"plugin/#adding-components-to-wai-annotations-through-plugins","text":"wai-annotations uses a plugin system to allow other libraries to add new processing components without modifying the base library source. This document details how to go about using this system.","title":"Adding components to wai-annotations through plugins"},{"location":"plugin/#plugin-types","text":"There are 4 types of components which can be added to wai-annotations via plugin: input formats, ISPs, XDCs and output formats. New domains can also be added, but these are specified indirectly via any of the previous components.","title":"Plugin Types"},{"location":"plugin/#domains","text":"New domains are added indirectly to wai-annotations as dependencies of components, as a domain which has no components is essentially unreachable to a conversion chain. However the specification of new domains is treated as a plugin-related issue, so it is detailed here. A domain is essentially the definition of an instance format, which contains both an item in the conversion dataset and the annotations attached to that item. The actual item in the dataset is represented by a FileInfo object, which contains the name of the item, and the binary data blob containing the item's file data. Domains need to specify a sub-class of FileInfo to represent the item and any additional data about it. The annotations for an instance can be any arbitrary type. To specify a new domain, a domain specifier must be created. This is achieved by importing the base classes from the core wai-annotations package and implementing the abstract methods. from typing import Type from wai.annotations.core.instance import FileInfo, Instance from wai.annotations.core.specifier import DomainSpecifier # Define the file-info type which holds dataset item data class MyFileInfo(FileInfo): @classmethod def from_file_data(cls, file_name: str, file_data: bytes) -> 'MyFileInfo': # If we don't need any additional information, or it is calculated in the init method return cls(file_name, file_data) # Define the type of annotations for the domain class MyAnnotations: ... # Define an instance type with additional functionality, if required class MyInstance(Instance[MyFileInfo, MyAnnotations]): def additional_method(self): ... # Define the domain specifier reporting the various classes for domain instances class MyDomainSpecifier(DomainSpecifier): @classmethod def domain_name(cls) -> str: return \"my domain\" @classmethod def file_type(cls) -> Type[MyFileInfo]: return MyFileInfo @classmethod def annotations_type(cls) -> Type[MyAnnotations]: return MyAnnotations # If our instances need additional functionality, we can override this method. The default is # wai.annotations.core.instance.Instance[cls.file_type(), cls.annotations_type()], and if we # do override this method, the type returned must inherit from this default type. @classmethod def instance_class(cls) -> Type[Instance]: return MyInstance","title":"Domains"},{"location":"plugin/#writing-new-components","text":"The base classes for components can be imported from wai-annotations' core package: from wai.annotations.core.component import Reader, InputConverter # For input formats from wai.annotations.core.component import InlineStreamProcessor # For ISPs from wai.annotations.core.component import CrossDomainConverter # For XDCs from wai.annotations.core.component import Writer, OutputConverter # For output formats Sub-class the base classes for the type of component you are trying to implement, and fill in the generic type-parameters and abstract methods. For generic type-parameters, component base classes vary on instance types, which are defined in the domain specifier for the domains the component operates in. Therefore the best way to specify the instance type-parameter is to import the domain specifiers for the domains of interest and use their instance_class() methods. For the abstract methods, each component has a few methods which require implementation. The purpose of each should be fairly self-explanatory, but the following examples will (hopefully) illustrate how to use each base class.","title":"Writing New Components"},{"location":"plugin/#input-formats","text":"Input formats consist of 2 components, a reader and an input-converter. The reader reads files from disk into an arbitrary format, and the input-converter converts that format into the instance format for the domain of the dataset. An example of how to implement a new input-format: from typing import Iterator, IO, Type from wai.annotations.core.component import Reader, InputConverter from wai.annotations.core.specifier import InputFormatSpecifier from wai.annotations.domain.image.object_detection import ImageObjectDetectionDomainSpecifier # Get the instance type from the domain specifier ImageObjectDetectionInstance = ImageObjectDetectionDomainSpecifier.instance_class() # Define the external format in any way you like (if being used with an output format as well, # define separately and import) class MyExternalFormat: @classmethod def from_annotation_file(cls, file: IO[bytes]) -> 'MyExternalFormat': ... @classmethod def from_negative_file(cls, file: IO[bytes]) -> 'MyExternalFormat': ... def to_image_object_detection_instance(self) -> ImageObjectDetectionInstance: ... # Define your reader, which parses files into your external format class MyReader(Reader[MyExternalFormat]): # Returns an iterator of instances in the given file, in case a single file # contains multiple dataset items def read_annotation_file(self, filename: str) -> Iterator[MyExternalFormat]: with open(filename, \"rb\") as file: yield MyExternalFormat.from_annotation_file(file) # Returns an iterator of negative instances in the given file def read_negative_file(self, filename: str) -> Iterator[MyExternalFormat]: with open(filename, \"rb\") as file: yield MyExternalFormat.from_negative_file(file) # Define your input converter, which converts your external format into the domain of interest (image object-detection # in this example) class MyInputConverter(InputConverter[MyExternalFormat, ImageObjectDetectionInstance]): # Converts the instance from its external format to the domain format def convert(self, instance: MyExternalFormat) -> Iterator[ImageObjectDetectionInstance]: yield instance.to_image_object_detection_instance() # Create a specifier to advertise our input format to the plugin system class MyInputFormatSpecifier(InputFormatSpecifier): # The domain of the input format @classmethod def domain(cls) -> Type[ImageObjectDetectionDomainSpecifier]: return ImageObjectDetectionDomainSpecifier # The reader class we defined earlier @classmethod def reader(cls) -> Type[MyReader]: return MyReader # The input converter class we defined earlier @classmethod def input_converter(cls) -> Type[MyInputConverter]: return MyInputConverter","title":"Input Formats"},{"location":"plugin/#inline-stream-processors","text":"from typing import Iterable, Optional, Set, Type from wai.annotations.core.component import InlineStreamProcessor from wai.annotations.core.specifier import ISPSpecifier, DomainSpecifier from wai.annotations.domain.image.object_detection import ImageObjectDetectionDomainSpecifier # Get the instance type from the domain specifier ImageObjectDetectionInstance = ImageObjectDetectionDomainSpecifier.instance_class() # Define the ISP class MyISP(InlineStreamProcessor[ImageObjectDetectionInstance]): # Takes an instance from the conversion stream and processes it. Returns an iterable so that new # instances can be injected into the conversion stream, or removed from it def _process_element(self, element: ImageObjectDetectionInstance) -> Iterable[ImageObjectDetectionInstance]: ... # Advertise the ISP to the plugin system via a specifier class MyISPSpecifier(ISPSpecifier): # Specifies the domains this ISP can operate on. None indicates any domain, and a set indicates # a set of specific domains @classmethod def domains(cls) -> Optional[Set[Type[DomainSpecifier]]]: return {ImageObjectDetectionDomainSpecifier} # The actual ISP type we defined earlier @classmethod def processor_type(cls) -> Type[InlineStreamProcessor]: return MyISP","title":"Inline Stream Processors"},{"location":"plugin/#cross-domain-converters","text":"from typing import Iterable, Type from wai.annotations.core.component import CrossDomainConverter from wai.annotations.core.specifier import XDCSpecifier, DomainSpecifier from wai.annotations.domain.image.classification import ImageClassificationDomainSpecifier from wai.annotations.domain.image.object_detection import ImageObjectDetectionDomainSpecifier # Get the instance types from the domain specifiers ImageClassificationInstance = ImageClassificationDomainSpecifier.instance_class() ImageObjectDetectionInstance = ImageObjectDetectionDomainSpecifier.instance_class() # Define your XDC, in this case converting from the image object-detection domain to # the image classification domain class MyXDC(CrossDomainConverter[ImageObjectDetectionInstance, ImageClassificationInstance]): # Convert the instance, returning an iterable again to allow insertion/deletion of instances def _convert_element(self, element: ImageObjectDetectionInstance) -> Iterable[ImageClassificationInstance]: ... # Define the specifier to advertise our new XDC to the plugin system class MyXDCSpecifier(XDCSpecifier): # Declare the input domain of the converter @classmethod def from_domain(cls) -> Type[DomainSpecifier]: return ImageObjectDetectionDomainSpecifier # Declare the output domain of the converter @classmethod def to_domain(cls) -> Type[DomainSpecifier]: return ImageClassificationDomainSpecifier # Advertise our XDC defined earlier @classmethod def converter(cls) -> Type[CrossDomainConverter]: return MyXDC","title":"Cross-Domain Converters"},{"location":"plugin/#output-formats","text":"Output formats also consist of 2 components, a writer and an output-converter. The output-converter converts instances from the domain format to an arbitrary external format for the output format, and the writer writes the instances in that format to disk. An example of how to implement a new output-format: from typing import Iterator, IO, Type, Iterable from wai.annotations.core.component import Writer, OutputConverter from wai.annotations.core.instance import FileInfo from wai.annotations.core.specifier import OutputFormatSpecifier, DomainSpecifier from wai.annotations.domain.image.object_detection import ImageObjectDetectionDomainSpecifier # Get the instance type from the domain specifier ImageObjectDetectionInstance = ImageObjectDetectionDomainSpecifier.instance_class() # Define the external format in any way you like (if being used with an input format as well, define # separately and import) class MyExternalFormat: @classmethod def from_image_object_detection_instance(cls, instance: ImageObjectDetectionInstance) -> 'MyExternalFormat': ... # Define your writer, which writes instances of your external format to disk class MyWriter(Writer[MyExternalFormat]): # Depending on the external format, it might write all instances to a single file, # or each instance to its own file in a directory. Provide some helpful information # on which is the case here @classmethod def output_help_text(cls) -> str: ... # How to write the actual instances to disk def write(self, instances: Iterable[MyExternalFormat], path: str): ... # Whether the output option should be a file (if not, then it should be # a directory) def expects_file(self) -> bool: ... # Lets wai-annotations extract the file from your external format def extract_file_info_from_external_format(self, instance: MyExternalFormat) -> FileInfo: ... # Define your output converter, which converts instances from the format's domain (image object-detection # in this example) into your external format class MyOutputConverter(OutputConverter[ImageObjectDetectionInstance, MyExternalFormat]): # Converts the instance from the domain format into your external format def convert(self, instance: ImageObjectDetectionInstance) -> Iterator[MyExternalFormat]: yield MyExternalFormat.from_image_object_detection_instance(instance) # Create a specifier to advertise our output format to the plugin system class MyOutputFormatSpecifier(OutputFormatSpecifier): # Specify the domain the format is in @classmethod def domain(cls) -> Type[DomainSpecifier]: return ImageObjectDetectionDomainSpecifier # Specify the writer we declared earlier @classmethod def writer(cls) -> Type[Writer]: return MyWriter # Specify the output converter we declared earlier @classmethod def output_converter(cls) -> Type[OutputConverter]: return MyOutputConverter","title":"Output Formats"},{"location":"plugin/#best-practice","text":"Although in each of the examples shown here, we have defined our plugin specifiers in the same file as the components they advertise, this is not the recommended approach. The specifier types should instead be defined in their own sub-package, and the methods should locally import the specified types (instead of globally at the beginning of the specifier Python file). This is so the specifier can be imported into the plugin system without importing potentially heavy-weight libraries that the components depend on for their functionality. This way the system can provide reflection of the available plugins, but only load those plugins that are actually selected for use in a conversion.","title":"Best Practice"},{"location":"plugin/#advertising-plugins","text":"In order for wai-annotations to recognise your plugin, the specified needs to be advertised as an entry point in your setup script under the wai.annotations.plugins group: # setup.py from setuptools import setup setup( ..., entry_points={ \"wai.annotations.plugins\": [ # Input Formats \"from-my-input-format=com.example.specifiers:MyInputFormatSpecifier\", # Output Formats \"to-my-output-format=com.example.specifiers:MyOutputFormatSpecifier\", # ISPs \"my-isp=com.example.specifiers:MyISPSpecifier\", # XDCs \"my-xdc=com.example.specifiers:MyXDCSpecifier\" ] } )","title":"Advertising Plugins"},{"location":"plugin/#adding-command-line-options-to-plugin-components","text":"TODO","title":"Adding Command-Line Options to Plugin Components"},{"location":"plugins/","text":"Plugins Processor stage CHECK-DUPLICATE-FILENAMES Causes the conversion stream to halt when multiple dataset items have the same filename Domain(s): Image Object-Detection Domain Speech Domain Image Classification Domain Image Segmentation Domain Options: usage: check-duplicate-filenames COERCE-BOX Converts all annotation bounds into box regions Domain(s): Image Object-Detection Domain Options: usage: coerce-box COERCE-MASK Converts all annotation bounds into polygon regions Domain(s): Image Object-Detection Domain Options: usage: coerce-mask CONVERT-IMAGE-FORMAT Converts images from one format to another Domain(s): Image Object-Detection Domain Image Classification Domain Image Segmentation Domain Options: usage: convert-image-format -f FORMAT optional arguments: -f FORMAT, --format FORMAT format to convert images to DIMENSION-DISCARDER Removes annotations which fall outside certain size constraints Domain(s): Image Object-Detection Domain Options: usage: dimension-discarder [--max-area MAX_AREA] [--max-height MAX_HEIGHT] [--max-width MAX_WIDTH] [--min-area MIN_AREA] [--min-height MIN_HEIGHT] [--min-width MIN_WIDTH] optional arguments: --max-area MAX_AREA the maximum area of annotations to convert --max-height MAX_HEIGHT the maximum height of annotations to convert --max-width MAX_WIDTH the maximum width of annotations to convert --min-area MIN_AREA the minimum area of annotations to convert --min-height MIN_HEIGHT the minimum height of annotations to convert --min-width MIN_WIDTH the minimum width of annotations to convert DISCARD-NEGATIVES Discards negative examples (those without annotations) from the stream Domain(s): Image Object-Detection Domain Speech Domain Image Classification Domain Image Segmentation Domain Options: usage: discard-negatives FILTER-LABELS Filters detected objects down to those with specified labels. Domain(s): Image Object-Detection Domain Options: usage: filter-labels [-l LABELS [LABELS ...]] [-r regexp] optional arguments: -l LABELS [LABELS ...], --labels LABELS [LABELS ...] labels to use -r regexp, --regexp regexp regular expression for using only a subset of labels MAP-LABELS Maps object-detection labels from one set to another Domain(s): Image Object-Detection Domain Options: usage: map-labels [-m old=new] optional arguments: -m old=new, --mapping old=new mapping for labels, for replacing one label string with another (eg when fixing/collapsing labels) OD-TO-IS Converts image object-detection instances into image segmentation instances Domain(s): Image Object-Detection Domain Options: usage: od-to-is [--label-error] --labels LABEL [LABEL ...] optional arguments: --label-error whether to raise errors when an unspecified label is encountered (default is to ignore) --labels LABEL [LABEL ...] specifies the labels for each index PASSTHROUGH Dummy ISP which has no effect on the conversion stream Domain(s): Image Object-Detection Domain Speech Domain Image Classification Domain Image Segmentation Domain Options: usage: passthrough REMOVE-CLASSES Removes classes from classification/image-segmentation instances Domain(s): Image Segmentation Domain Image Classification Domain Options: usage: remove-classes -c CLASS [CLASS ...] optional arguments: -c CLASS [CLASS ...], --classes CLASS [CLASS ...] the classes to remove STRIP-ANNOTATIONS ISP which removes annotations from instances Domain(s): Image Object-Detection Domain Speech Domain Image Classification Domain Image Segmentation Domain Options: usage: strip-annotations Sink stage TO-VOID-IC Consumes instances without writing them. Domain(s): Image Classification Domain Options: usage: to-void-ic TO-VOID-IS Consumes instances without writing them. Domain(s): Image Segmentation Domain Options: usage: to-void-is TO-VOID-OD Consumes instances without writing them. Domain(s): Image Object-Detection Domain Options: usage: to-void-od TO-VOID-SP Consumes instances without writing them. Domain(s): Speech Domain Options: usage: to-void-sp","title":"Plugins"},{"location":"plugins/#plugins","text":"","title":"Plugins"},{"location":"plugins/#processor-stage","text":"","title":"Processor stage"},{"location":"plugins/#check-duplicate-filenames","text":"Causes the conversion stream to halt when multiple dataset items have the same filename","title":"CHECK-DUPLICATE-FILENAMES"},{"location":"plugins/#domains","text":"Image Object-Detection Domain Speech Domain Image Classification Domain Image Segmentation Domain","title":"Domain(s):"},{"location":"plugins/#options","text":"usage: check-duplicate-filenames","title":"Options:"},{"location":"plugins/#coerce-box","text":"Converts all annotation bounds into box regions","title":"COERCE-BOX"},{"location":"plugins/#domains_1","text":"Image Object-Detection Domain","title":"Domain(s):"},{"location":"plugins/#options_1","text":"usage: coerce-box","title":"Options:"},{"location":"plugins/#coerce-mask","text":"Converts all annotation bounds into polygon regions","title":"COERCE-MASK"},{"location":"plugins/#domains_2","text":"Image Object-Detection Domain","title":"Domain(s):"},{"location":"plugins/#options_2","text":"usage: coerce-mask","title":"Options:"},{"location":"plugins/#convert-image-format","text":"Converts images from one format to another","title":"CONVERT-IMAGE-FORMAT"},{"location":"plugins/#domains_3","text":"Image Object-Detection Domain Image Classification Domain Image Segmentation Domain","title":"Domain(s):"},{"location":"plugins/#options_3","text":"usage: convert-image-format -f FORMAT optional arguments: -f FORMAT, --format FORMAT format to convert images to","title":"Options:"},{"location":"plugins/#dimension-discarder","text":"Removes annotations which fall outside certain size constraints","title":"DIMENSION-DISCARDER"},{"location":"plugins/#domains_4","text":"Image Object-Detection Domain","title":"Domain(s):"},{"location":"plugins/#options_4","text":"usage: dimension-discarder [--max-area MAX_AREA] [--max-height MAX_HEIGHT] [--max-width MAX_WIDTH] [--min-area MIN_AREA] [--min-height MIN_HEIGHT] [--min-width MIN_WIDTH] optional arguments: --max-area MAX_AREA the maximum area of annotations to convert --max-height MAX_HEIGHT the maximum height of annotations to convert --max-width MAX_WIDTH the maximum width of annotations to convert --min-area MIN_AREA the minimum area of annotations to convert --min-height MIN_HEIGHT the minimum height of annotations to convert --min-width MIN_WIDTH the minimum width of annotations to convert","title":"Options:"},{"location":"plugins/#discard-negatives","text":"Discards negative examples (those without annotations) from the stream","title":"DISCARD-NEGATIVES"},{"location":"plugins/#domains_5","text":"Image Object-Detection Domain Speech Domain Image Classification Domain Image Segmentation Domain","title":"Domain(s):"},{"location":"plugins/#options_5","text":"usage: discard-negatives","title":"Options:"},{"location":"plugins/#filter-labels","text":"Filters detected objects down to those with specified labels.","title":"FILTER-LABELS"},{"location":"plugins/#domains_6","text":"Image Object-Detection Domain","title":"Domain(s):"},{"location":"plugins/#options_6","text":"usage: filter-labels [-l LABELS [LABELS ...]] [-r regexp] optional arguments: -l LABELS [LABELS ...], --labels LABELS [LABELS ...] labels to use -r regexp, --regexp regexp regular expression for using only a subset of labels","title":"Options:"},{"location":"plugins/#map-labels","text":"Maps object-detection labels from one set to another","title":"MAP-LABELS"},{"location":"plugins/#domains_7","text":"Image Object-Detection Domain","title":"Domain(s):"},{"location":"plugins/#options_7","text":"usage: map-labels [-m old=new] optional arguments: -m old=new, --mapping old=new mapping for labels, for replacing one label string with another (eg when fixing/collapsing labels)","title":"Options:"},{"location":"plugins/#od-to-is","text":"Converts image object-detection instances into image segmentation instances","title":"OD-TO-IS"},{"location":"plugins/#domains_8","text":"Image Object-Detection Domain","title":"Domain(s):"},{"location":"plugins/#options_8","text":"usage: od-to-is [--label-error] --labels LABEL [LABEL ...] optional arguments: --label-error whether to raise errors when an unspecified label is encountered (default is to ignore) --labels LABEL [LABEL ...] specifies the labels for each index","title":"Options:"},{"location":"plugins/#passthrough","text":"Dummy ISP which has no effect on the conversion stream","title":"PASSTHROUGH"},{"location":"plugins/#domains_9","text":"Image Object-Detection Domain Speech Domain Image Classification Domain Image Segmentation Domain","title":"Domain(s):"},{"location":"plugins/#options_9","text":"usage: passthrough","title":"Options:"},{"location":"plugins/#remove-classes","text":"Removes classes from classification/image-segmentation instances","title":"REMOVE-CLASSES"},{"location":"plugins/#domains_10","text":"Image Segmentation Domain Image Classification Domain","title":"Domain(s):"},{"location":"plugins/#options_10","text":"usage: remove-classes -c CLASS [CLASS ...] optional arguments: -c CLASS [CLASS ...], --classes CLASS [CLASS ...] the classes to remove","title":"Options:"},{"location":"plugins/#strip-annotations","text":"ISP which removes annotations from instances","title":"STRIP-ANNOTATIONS"},{"location":"plugins/#domains_11","text":"Image Object-Detection Domain Speech Domain Image Classification Domain Image Segmentation Domain","title":"Domain(s):"},{"location":"plugins/#options_11","text":"usage: strip-annotations","title":"Options:"},{"location":"plugins/#sink-stage","text":"","title":"Sink stage"},{"location":"plugins/#to-void-ic","text":"Consumes instances without writing them.","title":"TO-VOID-IC"},{"location":"plugins/#domains_12","text":"Image Classification Domain","title":"Domain(s):"},{"location":"plugins/#options_12","text":"usage: to-void-ic","title":"Options:"},{"location":"plugins/#to-void-is","text":"Consumes instances without writing them.","title":"TO-VOID-IS"},{"location":"plugins/#domains_13","text":"Image Segmentation Domain","title":"Domain(s):"},{"location":"plugins/#options_13","text":"usage: to-void-is","title":"Options:"},{"location":"plugins/#to-void-od","text":"Consumes instances without writing them.","title":"TO-VOID-OD"},{"location":"plugins/#domains_14","text":"Image Object-Detection Domain","title":"Domain(s):"},{"location":"plugins/#options_14","text":"usage: to-void-od","title":"Options:"},{"location":"plugins/#to-void-sp","text":"Consumes instances without writing them.","title":"TO-VOID-SP"},{"location":"plugins/#domains_15","text":"Speech Domain","title":"Domain(s):"},{"location":"plugins/#options_15","text":"usage: to-void-sp","title":"Options:"},{"location":"usage/","text":"How to use wai-annotations from the command-line To convert a dataset using wai-annotations from the command-line, run the following command: wai-annotations convert [CONVERSION OPTIONS] \\ input-type [INPUT OPTIONS] \\ [ISP/XDC [ISP/XDC OPTIONS]]... \\ output-type [OUTPUT OPTIONS] (ISP=inline-stream-processor, XDC=cross-domain-conversion) For the available conversion options, see here . To list of available plugins in your environment, run: wai-annotations plugins For the available domains in your environment, run: wai-annotations domains The -h/--help option can be given at any point in a command-string to provide the options available at that point in the command. Examples of how to run wai-annotations can be found here .","title":"Usage"},{"location":"usage/#how-to-use-wai-annotations-from-the-command-line","text":"To convert a dataset using wai-annotations from the command-line, run the following command: wai-annotations convert [CONVERSION OPTIONS] \\ input-type [INPUT OPTIONS] \\ [ISP/XDC [ISP/XDC OPTIONS]]... \\ output-type [OUTPUT OPTIONS] (ISP=inline-stream-processor, XDC=cross-domain-conversion) For the available conversion options, see here . To list of available plugins in your environment, run: wai-annotations plugins For the available domains in your environment, run: wai-annotations domains The -h/--help option can be given at any point in a command-string to provide the options available at that point in the command. Examples of how to run wai-annotations can be found here .","title":"How to use wai-annotations from the command-line"}]}